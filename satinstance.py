from collections import defaultdict
from collections import Counter

class SATInstance:
    #we will be given a list of clauses
    #each clause is a list of literals
    #n total literals
    def __init__(self):
        self.comments = "c this was generated by satinstance.py \n"
        self.clauses = []
        self.count = 0
    
    def __str__(self):
        output = self.comments
        for clause in self.clauses:
            output += f"{" ".join(str(literal) for literal in clause)} 0 \n"
        output += "%\n0"
        return output

    def instance_from_file(cls, file):
        #construct instance
        instance = cls()
        #parse lines
        for line in file:
            line = line.strip()
            #comments
            if line.startswith("c"): continue
            #info
            if line.startswith("p"):
                instance.count = int(line.split()[2])
                continue
            #end
            if line.startswith("%"): break
            #clauses
            instance.add_clause(line)
        return instance
    
    def add_clause(self, line):
        clause = []
        for literal in line.split():
            if literal == "0": break #in used format, 0 is the end of a clause
            clause.append(int(literal))
        self.clauses.append(tuple(clause))

    def check(self, assignment):
        #updating clauses based on assignment 
        new_clauses = []
        for i, clause in enumerate(self.clauses):
            new_clause = SATInstance.check_clause(clause, assignment)
            #clause is true, so don't add it to new clauses
            if new_clause == True: continue
            #clause was set to false so unsat
            elif new_clause == False: return False
            #clause cannot be simplified as true or false, so add it to new clauses
            new_clauses.append(tuple(new_clause))
        self.clauses = new_clauses
        #if no new clauses left, then were satisfied
        if len(new_clauses) == 0: return True
        return None
        
    def check_clause(clause, assignment):
        #expression defaults to false
        expression = False
        new_clause = []
        for literal in clause:
            #if there is no assignment for the literal, add it to the new clause
            if assignment[abs(literal)-1] == None:
                new_clause.append(literal)
                continue
            #expression or (if literal is assigned to true)
            expression = expression or not assignment[abs(literal)-1] if literal < 0 else assignment[literal-1]
            #clause is true if any literal is true
            if expression: return True
        #if there is no new_clause and expression is False, then the clause is false
        if not expression and not new_clause: return False
        #if there is a new clause, return it
        return new_clause
    
    def is_twosat(self):
        #checks if we can run 2 sat
        for clause in self.clauses:
            if len(clause) > 2: return False
        return True

    def twosat(self):
        #running 2 sat
        graph = sat_graph()
        for clause in self.clauses:
            graph.add_clause(clause)
        if graph.has_contradiction(): return False
        self.clauses = []
        return True

    def find_pures(self):
        pures = set()
        not_pures = set()
        #for each literal in the clauses
        for clause in self.clauses:
            for literal in clause:
                #if the -literal is in pures, remove it from pures
                #and add the literal to not pures so it can never be added to pures again
                if -literal in pures:
                    pures.remove(-literal)
                    not_pures.add(abs(literal))
                #if the abs literal is not in not pures, then add the literal to pures
                elif abs(literal) not in not_pures:
                    pures.add(literal)
        return pures

    def find_units(self):
        #finds every unit value
        units = []
        for clause in self.clauses:
            if len(clause) == 1: units.append(clause[0])
        return units
    
    def stand(self, assignment):
        #run 2 sat if <=2 literals every clause
        if self.is_twosat(): return self.twosat()
        #assign pure literals so they're true
        for pure in self.find_pures(): assignment[abs(pure)-1] = False if pure < 0 else True
        #assign unit clauses to be true
        for unit in self.find_units(): assignment[abs(unit)-1] = False if unit < 0 else True 
        temp_clauses = self.clauses.copy()
        check = self.check(assignment)
        #check had a true or false, meaning there was a sat or unsat
        if check != None: return check
        #clauses were simplified, run stand again
        if self.clauses != temp_clauses: return self.stand(assignment)
        #no simplification happened, return None
        return None

    def most_frequent(self):
        counter = Counter()
        for clause in self.clauses:
            for literal in clause:
                counter[abs(literal)] += 1
        return counter.most_common()[0][0]
    
    def least_frequent(self):
        counter = Counter()
        for clause in self.clauses:
            for literal in clause:
                counter[abs(literal)] += 1
        return counter.most_common()[-1][0]

    def most_spread(self):
        counter = Counter()
        for clause in self.clauses:
            found = [False] * self.count
            for literal in clause:
                if found[abs(literal)-1]: continue
                counter[abs(literal)] += 1
                found[abs(literal)-1] = True
        return counter.most_common()[0][0]
    
    def solve(self, assignment, var_func):
        if (stand := self.stand(assignment)) != None: return stand
        var = var_func(self)
        for value in [True, False]:
            new_assignment = assignment.copy()
            new_assignment[var-1] = value
            temp_clauses = self.clauses.copy()
            if self.solve(new_assignment, var_func): return True
            self.clauses = temp_clauses
        return False

class sat_graph:
    def __init__(self):
        self.graph = defaultdict(set)
        self.nodes = set()
    
    def __str__(self):
        edges = ""
        for node in self.graph:
            for neighbor in self.graph[node]:
                edges += f"({node}, {neighbor})\n"
        return edges
        
    def addEdge(self, u, v):
        self.graph[u].add(v)
        self.nodes.add(u)
        self.nodes.add(v)
    
    def add_clause(self, clause):
        if len(clause) == 2:
            self.addEdge(-clause[0], clause[1])
            self.addEdge(-clause[1], clause[0])
        else:
            self.addEdge(-clause[0], clause[0])
    
    def has_contradiction(self):
        for component in self.strongly_connected_components():
            literals = set()
            for literal in component:
                if -literal in literals: return True
                literals.add(literal)
        return False

    def DFS(self, visited, stack, scc):
        for node in self.nodes:
            if node not in visited:
                self.traverse(visited, node, stack, scc)

    def traverse(self, visited, node, stack, scc):
        if node not in visited:
            visited.append(node)
            for neighbor in self.graph[node]:
                self.traverse(visited, neighbor, stack, scc)
            stack.append(node)
            scc.append(node)
        return visited

    def strongly_connected_components(self):
        stack = []
        sccs = []
        self.DFS([], stack, [])
        transposed = self.transpose_graph()
        visited = []
        while stack:
            node = stack.pop()
            if node not in visited:
                scc = []
                scc.append(node)
                transposed.traverse(visited, node, [], scc)
                sccs.append(scc)
        return sccs

    def transpose_graph(self):
        transposed = sat_graph()
        for node in self.graph:
            for neighbor in self.graph[node]:
                transposed.addEdge(neighbor, node)
        return transposed