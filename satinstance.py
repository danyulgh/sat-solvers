from collections import defaultdict

class SATInstance:
    #we will be given a list of clauses
    #each clause is a list of literals
    #n total literals
    def __init__(self):
        self.comments = "c this was generated by satinstance.py \n"
        self.sat = None
        self.clauses = []
        self.assignment = []

    def __str__(self):
        
        if self.sat == True: return self.comments
        if self.sat == False: return self.comments
        output = self.comments
        # output += f"p cnf {len(self.assignment)} {len(self.clauses)} \n"
        for clause in self.clauses:
            output += f"{" ".join(str(literal) for literal in clause)} 0 \n"
        output += "%\n0"
        return output
    
    def instance_from_file(cls, file):
        #construct instance
        instance = cls()
        #parse lines
        for line in file:
            line = line.strip()
            # print(line)
            #comments
            if line.startswith("c"): continue
            #info
            if line.startswith("p"):
                instance.assignment = [None] * int(line.split()[2])
                continue
            #end
            if line.startswith("%"): break
            #clauses
            instance.add_clause(line)
        return instance
    
    def add_clause(self, line):
        clause = []
        for literal in line.split():
            if literal == "0": break
            # encoded = int(literal) << 1 if not literal.startswith("-") else int(literal[1:]) << 1 ^ 1
            # clause.append(encoded)
            clause.append(int(literal))
        self.clauses.append(clause)

    def check(self, assignment):
        self.assignment = assignment.copy()
        new_clauses = []
        for i, clause in enumerate(self.clauses):
            new_clause = SATInstance.check_clause(clause, assignment)
            if new_clause == True: continue
            elif new_clause == False:
                self.comments += f"c clause {i+1} ({clause}) was set to false, causing unsat w/ current assignment\n"
                self.sat = False
                return False
            else: new_clauses.append(new_clause)
        self.clauses = new_clauses
        if len(new_clauses) == 0:
            self.comments += "c current partial assignment caused sat\n"
            self.sat = True
            return True
        self.comments += "c +1 check done \n"
        return new_clauses
        

    def check_clause(clause, assignment):
        expression = False
        new_clause = []
        for literal in clause:
            if assignment[abs(literal)-1] == None:
                new_clause.append(literal)
                continue
            expression = expression or not assignment[abs(literal)-1] if literal < 0 else assignment[literal-1]
            if expression: return True
        if not expression and not new_clause: return False
        return new_clause
    
    def is_twosat(self):
        for clause in self.clauses:
            if len(clause) > 2: return False
        return True

    def twosat(self):
        graph = sat_graph()
        for clause in self.clauses:
            graph.add_clause(clause)
        print("produced directed graph")
        print(graph)
        if graph.has_contradiction():
            self.comments += "c twosat unsatisfiable \n"
            self.sat = False
            return False
        else:
            self.comments += "c twosat satisfiable \n"
            self.sat = True
            self.clauses = []
            return True

    def find_pures(self):
        pures = set()
        not_pures = set()
        for clause in self.clauses:
            for literal in clause:
                if -literal in pures:
                    pures.remove(-literal)
                    not_pures.add(abs(literal))
                elif abs(literal) not in not_pures:
                    pures.add(literal)
        return pures

    def stand(self, assignment):
        if self.is_twosat(): 
            self.comments += "c running 2sat algorithm \n"
            self.twosat()
        for pure in self.find_pures():
            assignment[abs(pure) - 1] = False if pure < 0 else True
            self.comments += f"c pure literal {pure} set to {assignment[abs(pure) - 1]} \n"
        for clause in self.clauses:
            if len(clause) == 1:
                assignment[abs(clause[0])-1] = False if clause[0] < 0 else True 
                self.comments += f"c unit clause {clause[0]} set to {assignment[abs(clause[0])-1]} \n"
        temp_clauses = self.clauses.copy()
        check = self.check(assignment)
        print("\nmidway:")
        print(self)
        if check == True: self.comments += "c stand found true \n"
        elif check == False: self.comments += "c stand found false \n"
        elif self.clauses != temp_clauses:
            self.comments += "c rerunning stand \n"
            self.stand(assignment)
        else: self.comments += "c stand did not simplify \n"
        return self.clauses

class sat_graph:
    def __init__(self):
        self.graph = defaultdict(set)
        self.nodes = set()
    
    def __str__(self):
        edges = ""
        for node in self.graph:
            for neighbor in self.graph[node]:
                edges += f"({node}, {neighbor})\n"
        return edges
        
    def addEdge(self, u, v):
        self.graph[u].add(v)
        self.nodes.add(u)
        self.nodes.add(v)
    
    def add_clause(self, clause):
        if len(clause) == 2:
            self.addEdge(-clause[0], clause[1])
            self.addEdge(-clause[1], clause[0])
        else:
            self.addEdge(-clause[0], clause[0])
    
    def has_contradiction(self):
        for component in self.strongly_connected_components():
            literals = set()
            for literal in component:
                if -literal in literals: return True
                literals.add(literal)
        return False

    def DFS(self, visited, stack, scc):
        for node in self.nodes:
            if node not in visited:
                self.traverse(visited, node, stack, scc)

    def traverse(self, visited, node, stack, scc):
        if node not in visited:
            visited.append(node)
            for neighbor in self.graph[node]:
                self.traverse(visited, neighbor, stack, scc)
            stack.append(node)
            scc.append(node)
        return visited

    def strongly_connected_components(self):
        stack = []
        sccs = []
        self.DFS([], stack, [])
        transposed = self.transpose_graph()
        visited = []
        while stack:
            node = stack.pop()
            if node not in visited:
                scc = []
                scc.append(node)
                transposed.traverse(visited, node, [], scc)
                sccs.append(scc)
        return sccs

    def transpose_graph(self):
        transposed = sat_graph()
        for node in self.graph:
            for neighbor in self.graph[node]:
                transposed.addEdge(neighbor, node)
        return transposed